(ns pegthing.core
  (:require [clojure.set :as set])
  (:gen-class))

(declare successful-move prompt-move game-over query-rows)

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (println "Hello, World!"))


; tirangular numbers
; The first few expressions in this section of the code deal with triangular numbers.
; Triangular numbers are generated by adding the first n natural numbers. The first
; triangular number is 1, the second is 3 (1 + 2), the third is 6 (1 + 2 + 3), and so on.
; These numbers line up nicely with the position numbers at the end of every row on the board,
; which will turn out to be a very useful property.
(defn tri*
  "Generates lazy sequence of triangular numbers"
  ([] (tri* 0 1))
  ([sum n]
   (let [new-sum (+ sum n)]
     (cons new-sum (lazy-seq (tri* new-sum (inc n)))))))

(def tri (tri*))                                            ;(take 3 tri)

; figures out if its argument is in the tri lazy sequence. It works by using take-while to create a
; sequence of triangular numbers whose last element is a triangular number that’s less than or
; equal to the argument. Then it compares the last element to the argument
(defn triangular?
  "Is the number triangular? e.g. 1, 3, 6, 10, etc"
  [n]
  (= n (last (take-while #(>= n %) tri))))

(defn row-tri
  "The triangular number at the end of row n"
  [n]
  (last (take n tri)))
;(row-tri 3) -> 6

(defn row-num
  "Returns row number the position belongs to: pos 1 in row 1,
  positions 2 and 3 in row 2, etc"
  [pos]
  (inc (count (take-while #(> pos %) tri))))

; The first thing connect does is check whether the destination is actually a position on
; the board by confirming that it’s less than the board’s max position. For example, if
; you have five rows, the max position is 15. However, when the game board is created, the
; connect function will be called with arguments like (connect {} 15 7 16 22). The if
; statement at the beginning of connect makes sure your program doesn’t allow such outrageous
; connections, and simply returns the unmodified board when you ask it to do something silly.
;
; Next, connect uses recursion through reduce to progressively build up the final state of
; the board. In this example, you’re reducing over the nested vectors [[1 4] [4 1]]. This
; is what allows you to return an updated board with both pos and destination (1 and 4)
; pointing to each other in their connections.
(defn connect
  "Form a mutual connection between two positions"
  [board max-pos pos neighbor destination]
  (if (<= destination max-pos)
    (reduce (fn [new-board [p1 p2]]
              (assoc-in new-board [p1 :connections p2] neighbor))
            board
            [[pos destination] [destination pos]])
    board))
; (connect {} 15 1 2 4)

(defn connect-right
  [board max-pos pos]
  (let [neighbor (inc pos)
        destination (inc neighbor)]
    (if-not (or (triangular? neighbor) (triangular? pos))
      (connect board max-pos pos neighbor destination)
      board)))

(defn connect-down-left
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ row pos)
        destination (+ 1 row neighbor)]
    (connect board max-pos pos neighbor destination)))

(defn connect-down-right
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ 1 row pos)
        destination (+ 2 row neighbor)]
    (connect board max-pos pos neighbor destination)))






















